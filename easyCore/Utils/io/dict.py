from __future__ import annotations

__author__ = "https://github.com/materialsvirtuallab/monty/blob/master/monty/json.py"
__version__ = "3.0.0"
#  SPDX-FileCopyrightText: 2022 easyCore contributors  <core@easyscience.software>
#  SPDX-License-Identifier: BSD-3-Clause
#  Â© 2021-2022 Contributors to the easyCore project <https://github.com/easyScience/easyCore>


from typing import Optional, List, Dict, Any, TYPE_CHECKING

from easyCore.Utils.io.template import (
    BaseEncoderDecoder,
    recursive_encoder,
    get_class_module,
)

if TYPE_CHECKING:
    from easyCore.Objects.ObjectClasses import BV

_KNOWN_CORE_TYPES = ("Descriptor", "Parameter")

# def _load_redirect(redirect_file):
#     try:
#         with open(redirect_file, "rt") as f:
#             d = yaml.safe_load(f)
#     except IOError:
#         # If we can't find the file
#         # Just use an empty redirect dict
#         return {}
#
#     # Convert the full paths to module/class
#     redirect_dict = defaultdict(dict)
#     for old_path, new_path in d.items():
#         old_class = old_path.split(".")[-1]
#         old_module = ".".join(old_path.split(".")[:-1])
#
#         new_class = new_path.split(".")[-1]
#         new_module = ".".join(new_path.split(".")[:-1])
#
#         redirect_dict[old_module][old_class] = {
#             "@module": new_module,
#             "@class": new_class,
#         }
#
#     return dict(redirect_dict)


class DictSerializer(BaseEncoderDecoder):
    """
    This is a mix-in base class specifying an API for msonable objects. MSON
    is Monty JSON. Essentially, ComponentSerializer objects must implement an as_dict
    method, which must return a json serializable dict and must also support
    no arguments (though optional arguments to finetune the output is ok),
    and a from_dict class method that regenerates the object from the dict
    generated by the as_dict method. The as_dict method should contain the
    "@module" and "@class" keys which will allow the MontyEncoder to
    dynamically deserialize the class. E.g.::

        d["@module"] = self.__class__.__module__
        d["@class"] = self.__class__.__name__

    A default implementation is provided in ComponentSerializer, which automatically
    determines if the class already contains self.argname or self._argname
    attributes for every arg. If so, these will be used for serialization in
    the dict format. Similarly, the default from_dict will deserialization
    classes of such form. An example is given below::

        class MSONClass(ComponentSerializer):

        def __init__(self, a, b, c, d=1, **kwargs):
            self.a = a
            self.b = b
            self._c = c
            self._d = d
            self.kwargs = kwargs

    For such classes, you merely need to inherit from ComponentSerializer and you do not
    need to implement your own as_dict or from_dict protocol.

    New to Monty V2.0.6....
    Classes can be redirected to moved implementations by putting in the old
    fully qualified path and new fully qualified path into .monty.yaml in the
    home folder

    Example:
    old_module.old_class: new_module.new_class
    """

    # REDIRECT = _load_redirect(os.path.join(os.path.expanduser("~"), ".monty.yaml"))

    def encode(self, obj: BV, skip: List[str] = [], **kwargs):
        return self._convert_to_dict(obj, skip=skip, **kwargs)

    @classmethod
    def decode(cls, d: Dict) -> BV:
        """
        :param d: Dict representation.
        :return: ComponentSerializer class.
        """
        return BaseEncoderDecoder._convert_from_dict(d)

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> BV:
        """
        :param d: Dict representation.
        :return: ComponentSerializer class.
        """
        return BaseEncoderDecoder._convert_from_dict(d)


class DataDictSerializer(DictSerializer):
    """
    A class used to serialize a data dictionary.
    """

    def encode(self, obj, skip: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Convert the object to a dictionary.

        :param skip: Which items should be skipped.
        :return: Dictionary representation of the object.
        """
        if skip is None:
            skip = []
        elif isinstance(skip, str):
            skip = [skip]
        if not isinstance(skip, list):
            raise ValueError("Skip must be a list of strings.")
        encoded = super().encode(obj, skip=skip)
        return self._parse_dict(encoded)

    @classmethod
    def decode(cls, d: Dict[str, Any]) -> BV:
        raise NotImplementedError(
            "It is not possible to reconstitute objects from data only."
        )

    @staticmethod
    def _parse_dict(in_dict: Dict[str, Any]) -> Dict[str, Any]:
        out_dict = dict()
        for key in in_dict.keys():
            if key[0] == "@":
                if key == "@class" and in_dict[key] not in _KNOWN_CORE_TYPES:
                    out_dict["name"] = in_dict[key]
                continue
            out_dict[key] = in_dict[key]
            if isinstance(in_dict[key], dict):
                out_dict[key] = DataDictSerializer._parse_dict(in_dict[key])
            elif isinstance(in_dict[key], list):
                out_dict[key] = [
                    DataDictSerializer._parse_dict(x) if isinstance(x, dict) else x
                    for x in in_dict[key]
                ]
        return out_dict
